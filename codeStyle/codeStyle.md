> "Проект должен выглядеть так, будто его написал один человек"

_Мудрый самурай_

# 1. Общие правила

## 1.1. Общий код

Необходимо максимально переиспользовать существующий код. Если код найден в другом функционале, необходимо сделать
рефакторинг с выносом общего кода. Если код уже есть, то в новом функционале необходимо задействовать именно
его, а не писать похожий. НО! Нужно всегда понимать, что это именно _общий_ код и в перспективе он не будет меняться в
угоду конкретной бизнес-функциональности и обрастать ветвлениями. Тогда имеет смысл все-таки создать новый компонент.
Выносить что-то заранее не нужно, только то, что требует использования в нескольких местах уже сейчас.

## 1.2. Форматирование

Форматирование исходного кода осуществляется только пробелами.

Табуляция заменяется на пробелы: 1 табуляция = 2 пробела

Рекомендуемая длина строки – не более 120 символов. Для реализации этой рекомендации можно следовать следующим правилам:

- не более 2-х аргументов у функции; если аргументов больше — нужно использовать объект
- объект, в котором указано больше 1-го поля или массив с более, чем 1-им элементом, всегда переносятся
- если стрелочная функция не объявляется в вызове компонента или другой функции - тело обязательно переносится

Рекомендуется разделять логические блоки кода пустыми строками, но не более одной подряд идущей пустой строки. Также
избегаем пустых строк внутри блока в начале и в конце, согласно
eslint-правилу [padded-blocks](https://eslint.org/docs/rules/padded-blocks#never). Но отделять блоки с объявленными
константами пустой строкой от остального кода или блока с return (чтобы код не сливался)

- https://eslint.org/docs/rules/padding-line-between-statements#require-or-disallow-padding-lines-between-statements-padding-line-between-statements

Все инструкции должны оканчиваться точкой с запятой, где это предусмотрено.

## 1.3. Именование переменных, методов, классов, модулей и файлов

_Модуль_ именуется в camelCase, если он экспортирует объект, и в PascaleCase с большой буквы, если он экспортирует
конструктор.

_Класс_ всегда именуется в PascaleCase с большой буквы.

_Метод/функция_ именуется в camelCase; имя метода желательно начинать с глагола.

При именовании методов обработчиков рекомендуется придерживаться такого подхода в нейминге:

`<SomeComponent onClick={handleClick} />`

То есть сам метод в пропсах рекомендуется начинать с `on`, а функцию обработчик для такого метода начинать с `handle`

Импортируемая _переменная_ именуется, как и Модуль: в camelCase, если она представляет собой объект, функцию либо
примитив; и в PascaleCase с большой буквы, если в переменную записана функция-конструктор. Это правило касается
собственных модулей, для модулей из npm можно следовать документации.

Компонент _React_ именуется с заглавной буквы – это общее правило любых проектов на React. В названии компонента не
следует указывать суффикс `Component` (`Item`, но не `ItemComponent`).

Если файл компонента вложен в папку родительского компонента, при экспорте следует добавлять префикс, состоящий из имени
родительского компонента.

При этом корневой компонент экспортируется с тем же именем, что и сам модуль.

```javascript
/*
modules/
  - Users/
    - components
      - List.js
      - Item.js 
    - index.js
    - Users.js
*/

// содержимое modules/Users/components/Item.js
/* ... */
export { Item };

// содержимое modules/Users/components/List.js
/* ... */
export { List };

// содержимое modules/Users/Users.js
/* ... */
export { Users };

// содержимое modules/Users/index.js
export { Item as UsersItem } from '.components/Item';
export { List as UsersList } from '.components/List';
export { Users } from './Users';
```

При использовании аббревиатур в названии переменных, методов и т.п. заглавной является только первая буква (
например, `Sms`, `Http`).

Предпочтительно объявлять переменные и константы с помощью ключевых слов `let` и `const`. Используйте `var` только там,
где его использование целесообразно.

Объявляйте новые объекты и массивы с помощью сокращенного синтаксиса:

```js
// Плохо
const item = new Object();
const arr = new Array();

// Хорошо
const item = {};
const arr = [];
```

Если файл экспортирует _единственную_ сущность, название файла соответствует названию экспортируемой сущности, если
несколько однотипных сущностей - по типу сущности.

**Пример**

`useSomething.ts` - если внутри хук `useSomething` и `hooks.ts`, если внутри несколько хуков

## 1.4. Комментарии в коде

В общем случае отправлять в репозиторий комментированный код крайне нежелательно. Допускается оставлять в качестве
комментариев:

- важные предупреждения, например, как результат исправления бага;
- описание договоренности, если реализация выглядит неочевидной;
- код, который отключается на время по независящим от фронтенда причинам;
- описание известной недоработки, помеченное словами TODO или FIXME при этом обязательно указывайте в TODO свою фамилию
  в формате `\\ TODO-Surname`
- в моках – неиспользуемые заглушки (или части) ответов при условии, что они актуальны по формату ответа

Начинайте комментарий с пробела. Пишите комментарии _только на русском языке_

## 1.5. Репозиторий исходного кода (Git)

### 1.5.1 Правило именования ветвей

`<type>/<intitials>/<taskname><-description(optional)>`

**type**:

- feature - новая бизнес-функциональность
- pre-commit - все остальное

**initials**: ваши инициалы в латинице, которые позволяют вас однозначно опознать в проекте: `nsurname`, `namesurname`,
etc.

**taskname**: номер таска из Jira в формате `JIRATASK-000`

Пример: `pre-commit/aivanov/WEBCORE-001`

### 1.5.2 Правило формирования commit message

`<type>(<scope>): [JIRATASK-000]<subject>`

Сообщение коммита должно быть емким и отражать суть сделанных изменений. Предпочтительно также указывать модуль, в
котором было сделано изменение.

**Добавление в сообщение коммита ВАЛИДНОЙ сущности из JIRA обязательно!**

**type:**

- feat - разработка новой функциональности (новая страница, новая кнопка, новое поле ввода и т.д.).
- fix - исправление дефектов.
- docs - изменение в документации.
- refactor - изменения реализации с сохранением текущей функциональности.
- test - добавление/изменение тестов. Без влияния на production код.
- chore - обновление в механизме сборке. Без влияния на production код.

Примеры:

`feat(collapseheader): [WEBCORE1-0000]Разработка компонента a.CollapseHeader`
`feat(collapseheader): [WEBCORE1-0000][WEBCORE1-0001] Разработка компонента a.CollapseHeader` // где [WEBCORE1-0000]
номер feture, эпика, таски из JIRA с которой необходимо связать доработку
`fix(icon): [WEBCORE2-0000] Исправление опечатки в a.Icon`

_Компонент в круглых скобках **(scope)** указывать не обязательно_

`fix: [WEBCORE1-0000] История операций - исправление выбора даты`

`feat: [WEBCORE2-0000] Сбережения - добавлена страница с детальной информацией продукта (копилка)`

**Примеры плохих коммит сообщений:**

`fix: [TT-111] Фикс для релиза`

`feat: [GG-1] Новая страничка`

## 1.6. Добавление data-test-id

При написании бизнес-функционала рекомендуется к интерактивным (кнопки, ссылки, инпуты) и другим ключевым элементам (
возможно формы, таблицы) добавлять проп `data-test-id`, содержащий код, позволяющий однозначно определить элемент
интерфейса на странице. Для построения идентификатора можно использовать функцию `getDataTestId` из `ui-kit`.
data-test-id необходим для того, чтобы автотестеры в своих тестах могли однозначно обращаться к элементам на странице.

**Пример**

`<Button data-test-id="getDataTestId('ok_button', 'Button')" />`

## 1.7. Заполнение стандартного шаблона pull-request`а

При создании PR-a в develop или release ветки, пожалуйста, добавляйте в поле description стандартный шаблон и заполняйте
его, обязательно первый пункт "Краткое описание изменений". Это существенно облегчает ревью. Шаблон находится по
пути `.bitbucket/pull_request_template/pr_template.md`.

# 2. JavaScript

## 2.1 Индексный файл

Используется только для импортов в него и экспортов из него. В нем не должно быть другого кода.

`src/common/SomeFolder/index.ts`, где в индексе какой-то код и это единственный файл папки предпочтительнее заменить на

`src/common/SomeFolder.ts`, где будет помещен этот код. Это актуально для любого уровня вложенности.

К индексному файлу всегда обращаемся как к файлу, а не директории

**Хорошо:**

`import { something } from './src/common/whatever' - // это обращение к файлу `

**Плохо:**

`import { something } from './src/common/whatever/' - // это обращение к директории в которой есть индексный файл `

## 2.2 export

Стараемся избегать использования `default export` за исключением случаев, когда планируем использовать экспортируемое
через динамический импорт `import()`

## 2.3 Модули

Описание структуры и правила формирования модуля можно найти в `src\modules\README.md`

### Последовательность импортов

Мы стараемся выделять каждую из этих категорий в отдельный блок с пустой строкой после

1. Именованные импорты из `node_modules`

```javascript
import noop from 'lodash/noop';
```

2. **Не**именованные импорты из `node_modules` (редкий случай)

```javascript
import 'bootstrap/style.css';
```

3. Именованные абсолютные импорты

```javascript
import module from 'js/module';
```

4. Абсолютные **не**именованные импорты (редкий случай)

```javascript
import 'css/style.css';
```

5. Относительные именованные импорты. На ваше усмотрение: чем "дальше" импортируемый файл от исходного, тем выше импорт
   в списке.

```javascript
import CONSTANT from '../constant';
```

7. Относительные **не**именованные импорты

```javascript
import './style.css';
```

_Обратите внимание, что за порядком импортов следит линтер_

## 2.4. Локализованные строки

Строчные значения, которые используются в компонентах хранятся в файле `locale.ts` в виде `const locale`, представляющей
собой объект. Такой файл должен быть в каждом модуле.

**Пример**

файл locale.ts

```javascript
export const locale = {
  someText: 'Текст, который используется в компоненте',
};
```

использование locale SomeComponents.ts

```javascript
import { locale } from '../locale';

const SomeComponents = () => {
  return <div>{locale.someText}</div>;
};
```

## 2.5. Приведение типов

Для логических условий с проверкой существования переменной следует использовать `Boolean(anyVariable)` (
предпочтительно) или `!!anyVariable`. В JSX необходимо приводить к булевскому типу выражения, которые не должны
рендериться (например, условие рендера блока).

## 2.6. Константы

Константы уровня модуля («магические числа», строковые константы, параметры и т.п.) должны объявляться через `const` и
именоваться в UPPER_CASE с подчеркиванием, например:

```js
const FORMATTING_OPTIONS_AMOUNT = {
  thousandsSeparator: true,
  maxTwoDecimal: true,
  allowMinus: false,
};
```

Именование в UPPER_CASE не касается функций, а также констант, зависящих от других переменных. Имя сущности ссылочного
типа именуется в верхнем регистре, если она является иммутабельной. Поля такой сущности **всегда** именуется в нижнем
регистре.

## 2.7. Функции

Использование «стрелочных функций» приветствуется там, где возможно. Используйте «стрелочные функции» вместо сохранения
контекста (`let self = this`).

При **возможности** используйте сокращенный вид стрелочных функций без ключевого слова `return`. Если при использовании
сокращенного синтаксиса необходимо вернуть объект, его оборачивают в круглые скобки, чтобы интерпретатор отличил его от
тела функции.

## 2.8. Сравнения

Предпочтительно использовать операторы сравнения `===` и `!==`, а не `==` и `!=`. Исключениями являются сравнения
c `null` и `undefined`.

## 2.9. Пробелы и отступы

Ставьте один пробел перед открывающейся фигурной скобкой.

При объявлении анонимной функции через ключевое слово `function` ставьте один пробел перед открывающейся круглой
скобкой.

Ставьте один пробел перед круглой скобкой в `if`.

Разделяйте пробелом операнды бинарных и тернарных операторов (например, `a + b`). Содержимое объекта, записанного в
строку, должно отделяться от фигурных скобок пробелами (например, `{ a: '123' }`).

Не ставьте пробел при вызове функции.

**Пример:**

```js
function() {
  if (1 === 1) {
    console.log('test', 3 + 2);
  }
}
```

## 2.11. ESLint

При пересборке проекта и при коммите код прогоняется через анализатор ESLint. Перед коммитом кода в Git-репозиторий
необходимо исправить все обнаруженные проблемы.

_Этот раздел не завершен. Вы поможете проекту, исправив и дополнив его списком правил для ESLint._

## 2.12. Логирование

Перед пушем необходимо убедиться, что убраны все инструкции отладочного вывода в консоль,
например, `console.debug('…');`. Если вы сознательно оставили логирование, оставьте комментарий или TODO.

## 2.13. ES6 и выше

Желательно по максимуму использовать «плюшки» ES6 и последующих спецификаций. При этом не стоит забывать о нюансах:
например, использование arrow-функции меняет ее область замыкания.

Используйте деструктуризацию объектов, она позволяет делать код компактнее при повторяющихся обращениях к свойствам
объекта.

## 2.14. Особенности React

1. Предпочтение на проекте отдается использованию функциональных компонентов и хуков, однако не запрещается использовать
   классовые компоненты.

2. Чтобы избежать ситуаций, когда изменяется `state` не смонтированного компонента, нужно придерживаться следующих
   рекомендаций:

   - Вызывать `setState` только в методах `componentDidMount`, `componentDidUpdate` или в хэндлерах событий DOM. Это
     гарантирует то, что компонент смонтирован (mounted).
   - Если `setState` вызываются по событию (асинхронно относительно жизненного цикла компонента), то
     в `componentWillUnmount()` необходимо отписываться от события.

3. Строго не рекомендуется использование `forceUpdate`.

Рекомендуется размещать кастомные методы компонента в нем самом как свойства класса, особенно если в них к компоненте
обращаются через this. Крайне нежелательно влиять на дочерние компоненты вызовом их служебных методов (например, .show()
или .hide()). Вместо этого следует изменять props дочерних компонентов или «диспатчить» события.

### Использование хуков

1. Сложные вычисления рекомендуется оборачивать в `useMemo`.

2. Рекомендуемый порядок использования хука в компоненте - хуки-селекторы (`useSelector`, `useContext`),
   хук-действия (`useState`, `useQuery`, `useMutations`, `useDispatch`), хуки-хэндлеры (`useCallback`),
   хуки-эффекты (`useEffect`, `useLayoutEffect`)

## 2.13. JSX (TSX)

В одном _.jsx _.tsx файле **строго** рекомендуется описывать только один компонент, который и будет экспортирован.
Исключением являются только простые компоненты, полученные через `styled`. Остальные компоненты лучше разнести по
отдельным файлам.

**Пример:**

```jsx
const ItemWrapper = styled.div`
  background: red;
`;

export const Item = () => {
  return <ItemWrapper />;
};
```

**лучше, чем**

```jsx
const ItemWrapper = styled.div`
  background: red;
`;

export const Item = () => {
  return <ItemWrapper />;
};

export const OtherItem = () => {
  return <Item>OtherItem</Item>;
};

export const AndAnotherItem = () => {
  return <ItemWrapper>AnotherItem</ItemWrapper>;
};
```

## 2.14. Тестирование

Для реализации тестов используйте фреймворк Jest.

Старайтесь делать больше Unit-тестов и избегать написания интеграционных тестов, которые сложны как в разработке, так и
в поддержке.

## 2.15. SVG в JS

Допускается размещать SVG-изображения в JS-коде. Это полезно, где мы хотим избежать задержки при загрузке изображения
или использовать свойство `fill` для изменения цвета заливки. При вставке SVG необходимо "прогнать" через оптимизатор
SVGO и переделать некоторые теги в JSX.

При добавлении картинки в проект надо учитывать, что в будущем она может понадобиться в другом цвете и использовать fill
вместо stroke, чтобы красить через css. Дизайнеров можно просить переделать иконку "в аутлайны".

Если SVG имеет захардкоженные ширину/высоту и не подстраивается под передаваемые извне размеры, то в SVGO надо выбрать
чекбокс "Prefer viewBox to width/height", который не выбран по дефолту.

## 2.16. Типизация

Мы используем [Typescript](https://www.typescriptlang.org/)

Все порождённые нами типы именуются в соответствии с общими правилами именования и совпадают по названию с типизируемой
сущностью.

```javascript
// InfinityStone.ts
type Props = {};
type State = {};

class InfinityStone extends Component<Props, State> {
  /*... */
}
```

Экспортируемые типы, используемые в том числе вне файла, в котором они описаны, снабжаются
суффиксом `Type` `Interface` `Enum`. Если предполагается использование одних и тех же типов в нескольких местах, то
лучше всего описать их в файле `types.ts` и забирать оттуда. В том числе в пределах одного модуля.

```javascript
// InfinityStone.ts
type Props = {};
type State = {};
export type InfinityStoneType = {};

class InfiniTyStone extends Component<Props, State> {
  /*... */
}
```

Интерфейс должен использоваться для описания обязательства реализации:

```javascript
interface ChatterboxInterface {
  greetNeighbour: (name: string) => string;
}

class People implements ChatterboxInterface {
  greetNeighbour = (name: string = 'neighbour') => `Hello, ${name}!`;
}
```

Тип должен использоваться для описания структуры сущности:

```javascript
type UserType = {
  name: string,
  age: number,
};

function introduceUser({ name, age }: UserType) {
  return `My name is ${name}, I am ${age}`;
}
```

Старайтесь использовать описательные, а не однобуквенные имена, для переменных в generic-типах, там, где ожидается один
аргумент.

```javascript
Component < Props, State, Return >
```

**лучше, чем**

```javascript
Component < P, S, R >
```

А вот, например здесь, использование описательного имени переменной никаких плюсов не добавит и будет выглядеть излишне:

```javascript
interface GenericIdentityFn<T> {
  (arg: T): T;
}
```

Для описания типов входящих в компонент props лучше использовать декларацию типов props, а не описание всего компонента
в целом

**Пример**

```javascript
const YourComponent = (props: Props) => {
...
}
```

**лучше, чем**

```javascript
const YourComponent: React.FC<Props> = (props) => {
...
}
```

**Мотивация**

[https://github.com/facebook/create-react-app/pull/8177](https://github.com/facebook/create-react-app/pull/8177)

# 3. Styles and Components.

Для стилизации компонентов в проекте мы используем [styled-components](https://styled-components.com/)

## 3.1 Кастомные компоненты

В проекте используется ui-kit. Нужно стараться максимально использовать компоненты оттуда. Если вам в работу попадает
дизайн, с компонентом, который минимально отличается от того, что в пакете, не стоит бросаться сразу делать такой
компонент, нужно получить обоснование почему и зачем мы делаем так и зачем нам нужен именно такой новый компонент. После
этого нужно проверить, нет ли уже такого компонента в `src/components`, и если нет, то тогда уже приступать к
реализации.

Также, если компонент предполагается использовать в других предложениях приветствуются предложить доработку или создать
pull request в `ui-kit`

## 3.2. Рекомендации по написанию компонентов.

- Стараться максимально использовать возможности компонентов кита и по минимуму писать кастомный код.

**Пример:**

```jsx
<Flex direction={['column', 'row']} />
```

**лучше, чем**

```jsx
const ButtonWrapSkeletonStyled = styled(Flex)`
  flex-direction: column;

  ${adaptive.minWidth.tablet} {
    flex-direction: row;
  }
}
`;
```

- Стараться избегать описания функций в `css`. Лучше вынести их отдельно.

```javascript
const backgroundFunc = ({ color }) => `background: ${color}`;

const FlexBlock = styled.div`
  display: flex;
  ${backgroundFunc}
}`;
```

**лучше, чем**

```jsx
const FlexBlock = styled.div`
  display: flex;
  background: $({ color }) => background: ${color}
}`;
```

- Если вы планируете использовать ваши простые стилистические компоненты в нескольких местах вашего модуля, можно
  вынести такие компоненты отдельно в файл `styles.ts`. Чтобы не дергать такие файлы из компонент, рискуя создать
  циклическую зависимость.

## 3.4. Избегать вывода пропсов компонентов, как html-аттрибутов.

Если вы хотите, чтобы свойства, предназначенные для использования стилизованными компонентами, не передавались в
React-component и отображались в DOM элементе, стоит использовать префикс ($), он превратит его в временное свойство. В
примере ниже $draggable не отображается в DOM, как draggable.

```javascript
const Comp = styled.div`
  color: ${(props) => props.$draggable || 'black'};
`;

render(
  <Comp $draggable="red" draggable="true">
    Drag me!
  </Comp>,
);
```

https://styled-components.com/docs/api#transient-props
https://styled-components.com/docs/api#shouldforwardprop
